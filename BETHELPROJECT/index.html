<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Bethelsolv Standalone Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Apply a custom font for better aesthetics */
      body {
        font-family: 'Inter', sans-serif;
      }
      /* Ensure the canvas is responsive and maintains a 16:9 aspect ratio */
      .canvas-container {
        position: relative;
        width: 100%;
        padding-top: 56.25%; /* 16:9 Aspect Ratio */
      }
      .canvas-container canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      /* For text output that contains Markdown, apply the prose styles */
      .prose {
        max-width: none !important;
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet"/>
</head>
<body class="bg-gray-900 text-white min-h-screen p-4 md:p-8">
    <div id="root"></div>

    <!-- React + Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <!-- Math.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>

    <script type="text/babel">
      // Main App component for the Bethelsolv calculator
      function App() {
        // State variables for the main application
        const [activeTab, setActiveTab] = React.useState('real-analysis'); // 'real-analysis' or 'scientific'
        const [analysisSubTab, setAnalysisSubTab] = React.useState('limits'); // 'limits', 'continuity', 'differentiability'
        const [analysisFunction, setAnalysisFunction] = React.useState('x^2');
        const [analysisPoint, setAnalysisPoint] = React.useState(0);
        const [analysisResult, setAnalysisResult] = React.useState(null);
        const [analysisSolution, setAnalysisSolution] = React.useState('');
        const [scientificInput, setScientificInput] = React.useState('');
        const [scientificResult, setScientificResult] = React.useState('');
        const [isLoading, setIsLoading] = React.useState(false);
        const [error, setError] = React.useState('');
        
        // Refs for inputs and canvas
        const funcInputRef = React.useRef(null);
        const pointInputRef = React.useRef(null);
        const canvasRef = React.useRef(null);

        // Helper: Normalize user-entered math expression to be more forgiving
        const normalizeExpression = (raw) => {
          if (typeof raw !== 'string') return '';
          let s = raw.trim();

          if (s === '') return s;

          // replace common unicode characters
          s = s.replace(/π/g, 'pi');

          // map ln to log (natural log)
          s = s.replace(/\bln\b/g, 'log');

          // Put a '*' between number and variable or '(' => 2x -> 2*x, 2(x) -> 2*(x)
          // and between variable/closing-paren and variable/open-paren => x(x) -> x*(x), x2 -> x*2
          // Do this carefully to avoid breaking function names:
          s = s.replace(/(\d)\s*(?=\(?[a-zA-Zπ])/g, '$1*');        // 2x -> 2*x, 2sin -> 2*sin
          s = s.replace(/([a-zA-Z0-9_\)])\s+([a-zA-Z0-9_\(π])/g, '$1*$2'); // x y -> x*y  ; x(x) -> x*(x)

          // Auto-wrap common functions when user types `sin x` or `sinx` -> `sin(x)`
          const funcs = ['sin','cos','tan','asin','acos','atan','sqrt','log','exp','abs','sec','csc','cot'];
          funcs.forEach(fn => {
            // sin x  -> sin(x)
            const re1 = new RegExp('\\b' + fn + '\\b\\s+([0-9a-zA-Z_.\\-]+)', 'gi');
            s = s.replace(re1, (m,p1)=>`${fn}(${p1})`);
            // sinx -> sin(x) (only if immediately followed by letter/number without "(")
            const re2 = new RegExp('\\b' + fn + '([A-Za-z0-9_\\.])', 'gi');
            s = s.replace(re2, (m,p1)=>`${fn}(${p1})`);
          });

          // tidy up repeated spaces
          s = s.replace(/\s+/g, ' ');

          return s;
        };

        // Use an effect to re-plot the graph whenever relevant state changes
        React.useEffect(() => {
            const plotGraphWithState = () => {
                plotGraph(analysisFunction, analysisPoint, {
                    result: analysisResult,
                    subTab: analysisSubTab,
                });
            };
            plotGraphWithState(); // Initial plot
            window.addEventListener('resize', plotGraphWithState);
            return () => window.removeEventListener('resize', plotGraphWithState);
        }, [analysisFunction, analysisPoint, analysisResult, analysisSubTab]);

        // Use an effect to focus on the function input field when the tab changes
        React.useEffect(() => {
            if (activeTab === 'real-analysis' && funcInputRef.current) {
                funcInputRef.current.focus();
            }
        }, [activeTab]);

        // --- Core Real Analysis Logic ---

        // Function to compute the analysis based on the selected sub-tab
        const handleCompute = () => {
          setError('');
          setAnalysisResult(null);
          setAnalysisSolution('');
          setIsLoading(true);
          
          if (!window.math) {
            setError('Math.js library is not loaded yet. Please wait a moment.');
            setIsLoading(false);
            return;
          }
          
          try {
            const normalized = normalizeExpression(analysisFunction);
            // Quick parse check (attempt to compile) to catch syntax errors immediately.
            const compiledCheck = window.math.compile ? window.math.compile(normalized) : window.math.parse(normalized);

            const a = parseFloat(analysisPoint);
            if (isNaN(a)) {
              setError('Point of interest must be a valid number.');
              setIsLoading(false);
              return;
            }
            
            let result;
            let solution;
            switch (analysisSubTab) {
              case 'limits':
                result = computeLimit(normalized, a);
                solution = generateClientSideSolution('limits', analysisFunction, a, result);
                break;
              case 'continuity':
                result = checkContinuity(normalized, a);
                solution = generateClientSideSolution('continuity', analysisFunction, a, result);
                break;
              case 'differentiability':
                result = testDifferentiability(normalized, a);
                solution = generateClientSideSolution('differentiability', analysisFunction, a, result);
                break;
              default:
                result = { text: 'Invalid operation.' };
                solution = 'Invalid operation requested.';
                break;
            }
            setAnalysisResult(result.text);
            setAnalysisSolution(solution);
            
            // Plot the graph after computation
            plotGraph(analysisFunction, a, {
                result: result.text,
                subTab: analysisSubTab
            });

          } catch (e) {
            console.error("Error during computation:", e);
            if (e && e.message && (e.message.includes('Unexpected end of expression') || e.message.includes('Function not found'))) {
                setError(`Invalid function syntax. Please ensure your function is complete and correctly formatted (e.g., sin(x), log(x), x^2).`);
            } else {
                setError(`An error occurred: ${e && e.message ? e.message : e}. Please check your function and point.`);
            }
          } finally {
            setIsLoading(false);
            // Re-focus the input field after computation
            if (funcInputRef.current) {
                funcInputRef.current.focus();
            }
          }
        };
        
        // Helper function to compute the limit (numerical approximation)
        const computeLimit = (normalizedStr, a) => {
          const scope = { x: 0 };
          const h = 1e-6;
          try {
            scope.x = a - h;
            const leftLimit = window.math.evaluate(normalizedStr, scope);
            scope.x = a + h;
            const rightLimit = window.math.evaluate(normalizedStr, scope);
            
            if (!isFinite(leftLimit) || !isFinite(rightLimit)) {
              return { text: 'Could not compute limit (non-finite value encountered).', value: null };
            }
            
            if (Math.abs(leftLimit - rightLimit) < 1e-5) {
              return { text: `Limit is ${leftLimit.toFixed(6)}`, value: leftLimit };
            } else {
              return { text: `The limit does not exist.`, value: null };
            }
          } catch (e) {
            return { text: `Could not compute limit: ${e && e.message ? e.message : e}`, value: null };
          }
        };
        
        // Helper function to check continuity
        const checkContinuity = (normalizedStr, a) => {
          const scope = { x: a };
          const h = 1e-6;
          try {
            // Condition 1: f(a) is defined
            let fa;
            try {
              fa = window.math.evaluate(normalizedStr, scope);
              if (!isFinite(fa)) {
                return { text: 'Discontinuous: f(a) is not defined (non-finite).', continuous: false, fa: null };
              }
            } catch (e) {
              return { text: 'Discontinuous: f(a) is not defined.', continuous: false, fa: null };
            }
            
            // Condition 2: Limit exists
            scope.x = a - h;
            const leftLimit = window.math.evaluate(normalizedStr, scope);
            scope.x = a + h;
            const rightLimit = window.math.evaluate(normalizedStr, scope);
            if (!isFinite(leftLimit) || !isFinite(rightLimit)) {
              return { text: 'Discontinuous: one-sided limits are not finite.', continuous: false, fa: fa };
            }
            if (Math.abs(leftLimit - rightLimit) > 1e-5) {
              return { text: 'Discontinuous: The limit does not exist.', continuous: false, fa: fa };
            }
            const limit = leftLimit;
            
            // Condition 3: Limit equals f(a)
            if (Math.abs(limit - fa) < 1e-5) {
              return { text: 'The function is continuous at this point.', continuous: true, fa: fa };
            } else {
              return { text: 'Discontinuous: The limit is not equal to f(a).', continuous: false, fa: fa };
            }
          } catch (e) {
            return { text: `Could not check continuity: ${e && e.message ? e.message : e}`, continuous: false, fa: null };
          }
        };
        
        // Helper function to test differentiability (symbolic derivative where possible)
        const testDifferentiability = (normalizedStr, a) => {
          const scope = { x: a };
          try {
            // compute derivative symbolically then evaluate at x=a
            const derivativeNode = window.math.derivative(normalizedStr, 'x');
            // evaluate derivative by converting node to string (safe)
            const derivativeStr = derivativeNode.toString();
            const derivativeValue = window.math.evaluate(derivativeStr, scope);
            if (isFinite(derivativeValue)) {
              return { text: `The function is differentiable. Derivative: ${derivativeValue.toFixed(6)}.`, differentiable: true };
            } else {
              return { text: 'Not differentiable. The derivative does not exist (non-finite).', differentiable: false };
            }
          } catch (e) {
            return { text: 'Not differentiable. The derivative is not defined or could not be computed.', differentiable: false };
          }
        };

        // This is the function to generate the detailed solution (client-side)
        const generateClientSideSolution = (type, func, point, result) => {
            let solution = '';
            switch(type) {
                case 'limits':
                    solution = `### Detailed Solution for Limits
                    
To find the limit of f(x) = ${func} as x approaches a = ${point}, we check the behavior of the function from both the left and right sides of the point.
1.  Left-hand limit: evaluate f(x) for x slightly less than ${point}.
2.  Right-hand limit: evaluate f(x) for x slightly greater than ${point}.
3.  Conclusion: the limit exists if the two sides are equal.

Result: ${result.text}`;
                    break;
                case 'continuity':
                    solution = `### Detailed Solution for Continuity
                    
To determine if f(x) = ${func} is continuous at a = ${point}, check:
1. f(a) is defined.
2. The limit exists as x -> a.
3. The limit equals f(a).

Result: ${result.text}`;
                    break;
                case 'differentiability':
                    solution = `### Detailed Solution for Differentiability
                    
To check if f(x) = ${func} is differentiable at a = ${point}, we:
1. Check continuity at the point.
2. Compute the derivative and ensure it is finite at the point.

Result: ${result.text}`;
                    break;
                default:
                    solution = 'Solution generation not supported for this type.';
            }
            return solution;
        };
        
        // --- Graph Plotting Logic ---
        const plotGraph = (funcStr, point, analysisData) => {
          // If empty or invalid, clear canvas and return
          if (!window.math || !canvasRef.current || typeof funcStr !== 'string' || funcStr.trim() === '') {
            if (canvasRef.current) {
                const ctx = canvasRef.current.getContext('2d');
                ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
            }
            return;
          }

          const canvas = canvasRef.current;
          const ctx = canvas.getContext('2d');
          const dpr = window.devicePixelRatio || 1;
          const rect = canvas.getBoundingClientRect();
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;

          // reset transform and scale for crisp drawing
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          ctx.clearRect(0, 0, rect.width, rect.height);
          
          try {
            const normalized = normalizeExpression(funcStr);

            // compile the expression once for efficiency
            let compiled;
            try {
              compiled = window.math.compile(normalized);
            } catch (err) {
              // fallback to parse
              compiled = null;
            }

            const scope = { x: 0 };
            const xScale = rect.width / 10;
            const yScale = rect.height / 10;
            const xOffset = rect.width / 2;
            const yOffset = rect.height / 2;
            const step = 0.05; // Smaller step for smoother curves
            
            // Draw axes
            ctx.beginPath();
            ctx.strokeStyle = '#4B5563'; // Darker color for visibility
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.moveTo(0, yOffset);
            ctx.lineTo(rect.width, yOffset);
            
            // Y-axis
            ctx.moveTo(xOffset, 0);
            ctx.lineTo(xOffset, rect.height);
            ctx.stroke();
            
            // Draw labels and origin
            ctx.fillStyle = '#4B5563';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('0', xOffset - 10, yOffset - 10);
            ctx.fillText('x', rect.width - 15, yOffset - 15);
            ctx.fillText('y', xOffset - 15, 15);
            
            // Draw the function
            ctx.beginPath();
            ctx.strokeStyle = '#2563EB';
            ctx.lineWidth = 2;
            
            let isFirstPoint = true;
            for (let x = -5; x <= 5; x += step) {
              scope.x = x;
              let y;
              try {
                if (compiled) {
                  y = compiled.evaluate(scope);
                } else {
                  y = window.math.evaluate(normalized, scope);
                }
              } catch (err) {
                // skip invalid point
                continue;
              }
              if (isFinite(y)) {
                const canvasX = x * xScale + xOffset;
                const canvasY = -y * yScale + yOffset;
                if (isFirstPoint) {
                  ctx.moveTo(canvasX, canvasY);
                  isFirstPoint = false;
                } else {
                  ctx.lineTo(canvasX, canvasY);
                }
              }
            }
            ctx.stroke();

            // --- Add visualizations for Limits and Continuity ---
            if (analysisData && analysisData.result) {
              const a = parseFloat(point);
              if (!isNaN(a)) {
                const canvasX_a = a * xScale + xOffset;
                
                // Visualizing Continuity and Discontinuity
                if (analysisData.subTab === 'continuity') {
                    const continuityResult = checkContinuity(normalizeExpression(funcStr), a);
                    const fa = continuityResult.fa;
                    if (fa !== null && !continuityResult.continuous) {
                        // Draw a small red circle for discontinuity
                        const canvasY_fa = -fa * yScale + yOffset;
                        ctx.beginPath();
                        ctx.arc(canvasX_a, canvasY_fa, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = '#EF4444'; // Red color
                        ctx.fill();
                    }
                }

                // Visualizing Limits
                if (analysisData.subTab === 'limits' || analysisData.subTab === 'continuity') {
                    const limitResult = computeLimit(normalizeExpression(funcStr), a);
                    const limitValue = limitResult.value;

                    if (limitValue !== null && isFinite(limitValue)) {
                        const canvasY_limit = -limitValue * yScale + yOffset;

                        // Draw a small blue circle to show the limit point
                        ctx.beginPath();
                        ctx.arc(canvasX_a, canvasY_limit, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = '#3B82F6'; // Blue color
                        ctx.fill();
                    }
                }
              } // end if !isNaN(a)
            } // end if analysisData.result
          } catch (e) {
            console.error("Error plotting graph:", e);
          }
        };
        
        // --- Scientific Calculator Logic ---
        const handleScientificButtonClick = (value) => {
          if (!window.math) {
            setError('Math.js library is not loaded yet.');
            return;
          }
          if (value === 'C') {
            setScientificInput('');
            setScientificResult('');
            // keep focus
            if (funcInputRef.current) funcInputRef.current.focus();
          } else if (value === 'DEL') {
            setScientificInput((prev) => prev.slice(0, -1));
            if (funcInputRef.current) funcInputRef.current.focus();
          } else if (value === '=') {
            try {
              // Normalize common tokens for the scientific input as well
              const normalized = normalizeExpression(scientificInput);
              const result = window.math.evaluate(normalized);
              setScientificResult(window.math.format(result, { precision: 14 }));
            } catch (e) {
              setScientificResult('Error');
            } finally {
              if (funcInputRef.current) funcInputRef.current.focus();
            }
          } else if (['sin', 'cos', 'tan', 'sqrt', 'log', 'ln'].includes(value)) {
            // ln -> log mapping will be handled in normalizeExpression
            setScientificInput((prev) => prev + value + '(');
            if (funcInputRef.current) funcInputRef.current.focus();
          } else {
            setScientificInput((prev) => prev + value);
            if (funcInputRef.current) funcInputRef.current.focus();
          }
        };
        
        const ScientificCalculator = () => (
          <div className="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 w-full max-w-sm">
            <div className="bg-gray-900 p-4 rounded-lg border border-gray-700 mb-4 min-h-[5rem] flex flex-col justify-end items-end">
              <div className="text-right text-sm text-gray-400 break-all">{scientificInput}</div>
              <div className="text-right text-3xl text-white font-bold break-all">{scientificResult}</div>
            </div>
            <div className="grid grid-cols-5 gap-2">
              {['C', '(', ')', 'DEL', '/'].map(btn => (
                <button
                  key={btn}
                  type="button"
                  onMouseDown={(e) => { e.preventDefault(); handleScientificButtonClick(btn); }}
                  className="bg-gray-700 hover:bg-gray-600 text-white font-bold p-4 rounded-lg shadow-md transition-colors"
                >
                  {btn}
                </button>
              ))}
              {['sin', 'cos', 'tan', 'sqrt', '*'].map(btn => (
                <button
                  key={btn}
                  type="button"
                  onMouseDown={(e) => { e.preventDefault(); handleScientificButtonClick(btn); }}
                  className="bg-gray-700 hover:bg-gray-600 text-white font-bold p-4 rounded-lg shadow-md transition-colors"
                >
                  {btn}
                </button>
              ))}
              {['7', '8', '9', '^', '-'].map(btn => (
                <button
                  key={btn}
                  type="button"
                  onMouseDown={(e) => { e.preventDefault(); handleScientificButtonClick(btn); }}
                  className="bg-gray-700 hover:bg-gray-600 text-white font-bold p-4 rounded-lg shadow-md transition-colors"
                >
                  {btn}
                </button>
              ))}
              {['4', '5', '6', 'log', '+'].map(btn => (
                <button
                  key={btn}
                  type="button"
                  onMouseDown={(e) => { e.preventDefault(); handleScientificButtonClick(btn); }}
                  className="bg-gray-700 hover:bg-gray-600 text-white font-bold p-4 rounded-lg shadow-md transition-colors"
                >
                  {btn}
                </button>
              ))}
              {['1', '2', '3', 'ln', '='].map((btn, index) => (
                <button
                  key={btn}
                  type="button"
                  onMouseDown={(e) => { e.preventDefault(); handleScientificButtonClick(btn); }}
                  className={`font-bold p-4 rounded-lg shadow-md transition-colors ${index === 4 ? 'col-span-1 bg-blue-600 hover:bg-blue-700 text-white' : 'bg-gray-700 hover:bg-gray-600 text-white'}`}
                >
                  {btn}
                </button>
              ))}
              {['0', '.', 'pi', 'e'].map(btn => (
                <button
                  key={btn}
                  type="button"
                  onMouseDown={(e) => { e.preventDefault(); handleScientificButtonClick(btn); }}
                  className="bg-gray-700 hover:bg-gray-600 text-white font-bold p-4 rounded-lg shadow-md transition-colors"
                >
                  {btn}
                </button>
              ))}
            </div>
          </div>
        );
        
        // The Real Analysis calculator UI
        const RealAnalysisCalculator = () => (
          <div className="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
            <div className="flex justify-center border-b border-gray-700 mb-6">
              {['limits', 'continuity', 'differentiability'].map(tab => (
                <button
                  key={tab}
                  type="button"
                  onMouseDown={(e) => { e.preventDefault(); setAnalysisSubTab(tab); if (funcInputRef.current) funcInputRef.current.focus(); }}
                  className={`py-3 px-6 text-sm font-semibold transition-colors duration-300 ${analysisSubTab === tab ? 'border-b-2 border-blue-500 text-blue-400' : 'text-gray-400 hover:text-white'}`}
                >
                  {tab.charAt(0).toUpperCase() + tab.slice(1)}
                </button>
              ))}
            </div>
            
            <div className="mb-4">
              <label htmlFor="func-input" className="block text-sm font-medium text-gray-300 mb-1">Function f(x):</label>
              <input
                id="func-input"
                type="text"
                autoFocus
                ref={funcInputRef}
                value={analysisFunction}
                onChange={(e) => {
                  setAnalysisFunction(e.target.value);
                  // keep focus on the input after each keystroke (should remain)
                  if (funcInputRef.current) {
                    funcInputRef.current.focus();
                  }
                }}
                placeholder="e.g., x^2, sin(x)"
                className="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200"
              />
            </div>
            <div className="mb-6">
              <label htmlFor="point-input" className="block text-sm font-medium text-gray-300 mb-1">Point a:</label>
              <input
                id="point-input"
                type="number"
                ref={pointInputRef}
                value={analysisPoint}
                onChange={(e) => {
                  setAnalysisPoint(e.target.value);
                  // Keep focus in the point input if user is editing it
                  if (pointInputRef.current) {
                    pointInputRef.current.focus();
                  }
                }}
                placeholder="e.g., 0, 1"
                className="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200"
              />
            </div>
            
            <button
              type="button"
              onMouseDown={(e) => { e.preventDefault(); handleCompute(); if (funcInputRef.current) funcInputRef.current.focus(); }}
              disabled={isLoading}
              className="w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 disabled:opacity-50 transition duration-300 mb-6"
            >
              Compute
            </button>
            
            {/* Results and Solution section */}
            <div className="bg-gray-900 p-4 rounded-lg border border-gray-700 min-h-[150px] overflow-auto">
              {isLoading ? (
                <div className="flex justify-center items-center h-full flex-col">
                  <div className="w-10 h-10 border-4 border-t-4 border-gray-600 border-t-blue-500 rounded-full animate-spin"></div>
                  <p className="mt-4 text-sm text-gray-400">Computing solution...</p>
                </div>
              ) : error ? (
                <p className="text-red-400 font-semibold text-center">{error}</p>
              ) : analysisResult ? (
                <div className="space-y-4">
                  <h3 className="text-xl font-bold text-blue-300">Result:</h3>
                  <p className="text-lg text-white">{analysisResult}</p>
                  {analysisSolution && (
                    <React.Fragment>
                      <h3 className="text-xl font-bold text-blue-300 mt-6">Detailed Solution:</h3>
                      <div className="prose prose-sm prose-invert text-gray-300 leading-relaxed max-w-none">
                        <p>{analysisSolution}</p>
                      </div>
                    </React.Fragment>
                  )}
                </div>
              ) : (
                <p className="text-gray-500 italic text-center">Results and solutions will appear here.</p>
              )}
            </div>
          </div>
        );
        
        return (
          <div className="max-w-6xl mx-auto">
            <h1 className="text-5xl font-extrabold text-center text-blue-400 mb-2">Bethelsolv</h1>
            <p className="text-center text-gray-400 mb-8">A computational tool for Real Analysis & Scientific calculations.</p>
            
            {/* Tab switcher */}
            <div className="flex justify-center mb-8">
              <button
                onClick={() => { setActiveTab('real-analysis'); if (funcInputRef.current) funcInputRef.current.focus(); }}
                className={`py-3 px-6 text-lg font-bold transition-colors duration-300 rounded-l-lg ${activeTab === 'real-analysis' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
              >
                Real Analysis
              </button>
              <button
                onClick={() => { setActiveTab('scientific'); if (funcInputRef.current) funcInputRef.current.focus(); }}
                className={`py-3 px-6 text-lg font-bold transition-colors duration-300 rounded-r-lg ${activeTab === 'scientific' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
              >
                Scientific
              </button>
            </div>
            
            {activeTab === 'real-analysis' && (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {/* Analysis Section */}
                <div className="md:order-2">
                  <h2 className="text-2xl font-semibold mb-4 text-center">Function Analysis</h2>
                  <RealAnalysisCalculator />
                </div>
                
                {/* Graphing Panel */}
                <div className="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 flex flex-col items-center md:order-1">
                  <h2 className="text-2xl font-semibold mb-4 text-center">Graph Plotting</h2>
                  <div className="canvas-container">
                    <canvas ref={canvasRef} className="bg-gray-100 rounded-lg shadow-inner"></canvas>
                  </div>
                </div>
              </div>
            )}
            
            {activeTab === 'scientific' && (
              <div className="flex justify-center">
                <ScientificCalculator />
              </div>
            )}
            
          </div>
        );
      };
      
      // Render the App component into the root element
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
